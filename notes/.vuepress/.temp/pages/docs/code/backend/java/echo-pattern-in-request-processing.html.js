import comp from "/Users/wangwenpeng/Code/area/notes/.vuepress/.temp/pages/docs/code/backend/java/echo-pattern-in-request-processing.html.vue"
const data = JSON.parse("{\"path\":\"/docs/code/backend/java/echo-pattern-in-request-processing.html\",\"title\":\"请求处理流中的\\\"回响模式\\\"：利用拦截器为过滤器提供上下文\",\"lang\":\"zh-CN\",\"frontmatter\":{\"title\":\"请求处理流中的\\\"回响模式\\\"：利用拦截器为过滤器提供上下文\",\"icon\":\"file\",\"order\":null,\"date\":\"2025-04-27T00:00:00.000Z\",\"category\":[\"Java\"],\"tags\":[\"SpringBoot\",\"Filter\",\"Interceptor\",\"架构设计\",\"设计模式\",\"日志记录\",\"API监控\"],\"description\":\"1. 引言 在现代 Web 应用开发中，请求处理流程的复杂性日益增长。从简单的 CRUD 操作到复杂的业务逻辑处理，每一个 HTTP 请求都需要经历多个处理层次：跨域处理、身份认证、权限校验、参数验证、业务逻辑执行、日志记录等。这些横切关注点的处理通常依赖于 Spring 框架提供的过滤器（Filter）和拦截器（Interceptor）机制。 然而，...\",\"head\":[[\"script\",{\"type\":\"application/ld+json\"},\"{\\\"@context\\\":\\\"https://schema.org\\\",\\\"@type\\\":\\\"Article\\\",\\\"headline\\\":\\\"请求处理流中的\\\\\\\"回响模式\\\\\\\"：利用拦截器为过滤器提供上下文\\\",\\\"image\\\":[\\\"\\\"],\\\"datePublished\\\":\\\"2025-04-27T00:00:00.000Z\\\",\\\"dateModified\\\":null,\\\"author\\\":[{\\\"@type\\\":\\\"Person\\\",\\\"name\\\":\\\"Wang Wenpeng\\\",\\\"url\\\":\\\"hachinekooo.github.io\\\"}]}\"],[\"meta\",{\"property\":\"og:url\",\"content\":\"https://hachinekooo.github.io/docs/code/backend/java/echo-pattern-in-request-processing.html\"}],[\"meta\",{\"property\":\"og:site_name\",\"content\":\"乐观的小八\"}],[\"meta\",{\"property\":\"og:title\",\"content\":\"请求处理流中的\\\"回响模式\\\"：利用拦截器为过滤器提供上下文\"}],[\"meta\",{\"property\":\"og:description\",\"content\":\"1. 引言 在现代 Web 应用开发中，请求处理流程的复杂性日益增长。从简单的 CRUD 操作到复杂的业务逻辑处理，每一个 HTTP 请求都需要经历多个处理层次：跨域处理、身份认证、权限校验、参数验证、业务逻辑执行、日志记录等。这些横切关注点的处理通常依赖于 Spring 框架提供的过滤器（Filter）和拦截器（Interceptor）机制。 然而，...\"}],[\"meta\",{\"property\":\"og:type\",\"content\":\"article\"}],[\"meta\",{\"property\":\"og:locale\",\"content\":\"zh-CN\"}],[\"meta\",{\"property\":\"article:tag\",\"content\":\"API监控\"}],[\"meta\",{\"property\":\"article:tag\",\"content\":\"日志记录\"}],[\"meta\",{\"property\":\"article:tag\",\"content\":\"设计模式\"}],[\"meta\",{\"property\":\"article:tag\",\"content\":\"架构设计\"}],[\"meta\",{\"property\":\"article:tag\",\"content\":\"Interceptor\"}],[\"meta\",{\"property\":\"article:tag\",\"content\":\"Filter\"}],[\"meta\",{\"property\":\"article:tag\",\"content\":\"SpringBoot\"}],[\"meta\",{\"property\":\"article:published_time\",\"content\":\"2025-04-27T00:00:00.000Z\"}]]},\"readingTime\":{\"minutes\":6.65,\"words\":1995},\"filePathRelative\":\"docs/code/backend/java/echo-pattern-in-request-processing.md\",\"excerpt\":\"<h2>1. 引言</h2>\\n<p>在现代 Web 应用开发中，请求处理流程的复杂性日益增长。从简单的 CRUD 操作到复杂的业务逻辑处理，每一个 HTTP 请求都需要经历多个处理层次：跨域处理、身份认证、权限校验、参数验证、业务逻辑执行、日志记录等。这些横切关注点的处理通常依赖于 Spring 框架提供的过滤器（Filter）和拦截器（Interceptor）机制。</p>\\n<p>然而，在实际开发过程中，我们经常遇到这样的困境：过滤器虽然执行得最早，但无法获取到控制器的详细信息；拦截器能够访问 HandlerMethod 等丰富的上下文，却无法将这些信息有效地传递回过滤器层进行统一处理。这种单向的信息流动限制了我们在架构设计上的灵活性。</p>\",\"autoDesc\":true}")
export { comp, data }

if (import.meta.webpackHot) {
  import.meta.webpackHot.accept()
  if (__VUE_HMR_RUNTIME__.updatePageData) {
    __VUE_HMR_RUNTIME__.updatePageData(data)
  }
}

if (import.meta.hot) {
  import.meta.hot.accept(({ data }) => {
    __VUE_HMR_RUNTIME__.updatePageData(data)
  })
}
