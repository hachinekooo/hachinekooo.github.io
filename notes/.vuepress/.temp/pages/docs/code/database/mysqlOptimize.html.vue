<template><div><h2 id="覆盖索引" tabindex="-1"><a class="header-anchor" href="#覆盖索引"><span>覆盖索引</span></a></h2>
<blockquote>
<p>查询的列要被所建的索引覆盖到</p>
</blockquote>
<p>为了避免回表查询，导致的不必要的性能损耗。</p>
<p>在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引，而非单列索引。</p>
<h2 id="索引设计原则" tabindex="-1"><a class="header-anchor" href="#索引设计原则"><span>索引设计原则</span></a></h2>
<ul>
<li>
<p>针对于数据量较大，且查询比较频繁的表建立索引。</p>
</li>
<li>
<p>针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引。</p>
</li>
<li>
<p>尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。</p>
</li>
<li>
<p>如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。</p>
</li>
<li>
<p>尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率。</p>
</li>
<li>
<p>要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率。</p>
</li>
<li>
<p>如果索引列不能存储 NULL 值，请在创建表时使用 NOT NULL 约束它。当优化器知道每列是否包含 NULL 值时，它可以更好地确定哪个索引最有效地用于查询。</p>
</li>
</ul>
<h2 id="索引失效的情况" tabindex="-1"><a class="header-anchor" href="#索引失效的情况"><span>索引失效的情况</span></a></h2>
<ul>
<li>用 or 分割开的条件，如果 or 前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到。当 or 连接的条件，左右两侧字段都有索引时，索引才会生效。</li>
<li>没有遵守最左前缀法则，使用条件时第一个条件不是联合索引的第一个字段；如果使用的联合索引的开头但是条件中跳过了联合索引的部分字段，则从断开处后面的索引失效。</li>
<li>计算、函数、类型转换（自动 or 手动，如果字符串不加单引号，对于查询结果，没什么影响，但是数据库存在隐式类型转换，索引将失效），会导致索引失效而转向全表扫描</li>
<li>使用 like 模糊查询时，如果查询的关键字以%开头，则索引失效，以%结尾没事。</li>
<li>mysql 在使用不等于(!= 或者&lt;&gt;)的时候无法使用索引会导致全表扫描；业务允许的情况下尽量使用&gt;=</li>
<li>is null，is not null 也无法使用索引</li>
</ul>
</div></template>


